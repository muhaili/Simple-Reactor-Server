# Simple-Reactor-Server
基于c++Reactor模式实现的简易Http服务器
1.本项目使用c++实现了一个简易的并发Http服务器。这是一个初级版本，由于刚写完并没有来得及分文件，以及大量使用裸指针，涉及大量手动delete，好像是有那么一点内存泄露的问题，因为我没好好写析构（。但是运行是没问题的，简单做了一个压测，效果也还不错。当然这是因为处理数据的逻辑很简易，也是本机访问的，没有什么网络传播时延。然后除了parse之后的回复那边用ai处理了一下回复逻辑以外（因为我不是很熟悉html），其他纯人工手打。
2.压测表现：
<img width="377" height="223" alt="image" src="https://github.com/user-attachments/assets/825085e6-35d5-4668-b6ec-ee2d0bb00455" />

3.关于本项目涉及到的知识点：
1.关于网络编程api的使用和知识：
说明：
在Linux的进程中，我们有一个文件描述符表，一个文件编号对应着一个对象。换言之，经过这层抽象，监视文件编号等价于监视文件。（下文可能不区分）。

Epoll_create():用于创建一个epoll实例，它被用来监视对象。
Epoll_event：关于对象的档案。
有两个成员，一个是events：记录触发方式，一个是data，用于存放对象的信息。
（后面会具体补充触发方式的内容）。
epoll_wait(epfd, events, 100, -1):
参数分别是epoll实例的文件编号，event数组，监视连接的最大数量，超时时长。
阻塞等待，被监视对象们有响动时返回，有响动的对象的档案被返回到event数组中。

监控器epoll只需要知道对象的对应编号就能很好地完成监控的本职工作。我们为监视的对象建立一个监视档案，仅是供开发者方便使用。比如当我们想为客户维护一个连接信息，但客户在通信上对于我们来说只是一个套接字编号，当客户向我们发消息，我们想修改连接信息状态，怎么找到客户n号对应的那个连接信息呢？由我们自己维护一张map吗？Key是用户的套接字，val是那个结构体指针？
贴心的epoll为我们实现了这个功能，它为我们留下了一个放档案的空位。Epoll用于监控对象所创造的（简化）结构体大概长这样：
<img width="415" height="100" alt="image" src="https://github.com/user-attachments/assets/6d8862b5-77b9-4bca-98c6-3d9c8e092651" />


它并不关心event的数据里放了什么，那是开发者关心的。只是当它返回有响动的套接字的时候，它把这个event返还给开发者，开发者通过预先填写的event直接拿到了与该套接字对应的连接信息，并能进行操作。
Epitem结构体存放的其他信息包括：该对象被谁监视（epoll实例对应的epfd），红黑树相关信息...
关于epoll是怎么实现它的监控本职功能的，我也想聊聊：
刚刚我们聊到了epoll为一个被监控对象所创建的节点大概长什么样。
这些节点们是用红黑树的架构被串起来的，主要是根据编号组织的，方便查找。比如当我们想改某个节点的信息，提供编号就能在O(logN)的时间内找到节点。
当我们决定要监视一个套接字对象的时候，我们为对象建立一个节点，把它按照编号挂到红黑树上。然后我们创建一个叫struct eppoll_entry的结构体，把它挂到套接字的等待队列里边，这个结构体包含了一个函数指针和一个指向对象节点的指针。当套接字对应的那条线路来了数据，内核会遍历等待队列里的结构体，执行它们的函数指针指向的handle函数。
Handle函数会判断当前来的数据情况是否满足设定的触发方式。如果满足，就会把指向对象节点的指针（epitem*）放到一个就绪链表里面，并且唤醒在epoll_wait()阻塞的进程。（从中断态切换到运行态，这里也值得一说，epoll实例也维护一个等待队列，挂着阻塞在这个epoll上的进程，由于epitem存了被谁监视（也就是epoll实例相关的信息），所以可以找到这个epoll实例的等待队列，然后对队列中的进程改状态）。
Epoll_wait()被唤醒后会将就绪链表中节点中的event写到开发者提供的那个events数组中去，并返回event数量。
接下来聊下触发方式：
EPOLLIN (读)：
LT：缓冲区有东西就响铃。
ET：缓冲区新进了东西才响铃。
EPOLLOUT (写)：
LT：缓冲区不满（能写进去）就响铃。
ET：缓冲区由满变不满（腾出空间）才响铃。
模式设置：
EPOLLET：显式开启边缘触发。
LT 模式：无专门宏，不写 EPOLLET 默认为此。

项目架构：
采用主从reactor模式+工作线程模式。
主线程负责监听新连接，然后把新客户交给从线程管理，从线程为新客户创建套接字，并管理后续通信的收发。对用户的请求，需要进行解析，并进行相应回复，从线程会把这项工作交给工作线程完成。我们有一个从线程池和一个工作线程池。
下面进行详细说明：
主线程：在127.0.0.1的8888端口注册一个套接字，并监听这个套接字。
主线程和从线程之间的通信是通过eventfd+队列实现的。从线程在初始化时，会创建一个eventfd，注册到监听表中，并在epoll_wait()阻塞等待。当主线程收到新连接，会将该套接字推进从线程的客户队列，并向eventfd中写值，epoll_wait（）发现有套接字可读，被唤醒，处理主线程的新客户请求，也就是将客户套接字添加到监听表中。
对于从线程，从epoll_wait()中苏醒有两种情况，一种是来自主线程的新客户添加监听请求，一种是来自客户的工作消息（读或者需要回复）。先说添加监听的情况，除了将套接字注册进监听表以外，我们为每位客户建立了一个档案（HttpConnection*），其中包含了从线程epoll（int epfd)，消息区（string），回复区（string）,客户套接字（int efd)。
从线程用线程通过初始化函数实现：首先我们要写一个工作逻辑函数（监听+处理），然后将这个函数交给一个线程，接着让线程detach。

从线程通知工作线程的通信是通过条件变量+队列实现的。当从线程收到来自用户的消息（可读触发），会通过read将消息读到指定的char数组里，并将消息添加到用户消息区（HttpConnection中的readBuffer）。接下来处理消息：当该消息包含了至少一条完整消息，我们取出该完整消息，将其放进工作线程的消息队列，并从消息区里擦除这条消息。直到消息区不再剩下可以被处理的完整消息。
工作线程的启动和从线程的初始化差别不大。不过在被调用上存在区别。从线程是由主线程指定编号调用的，保证每个客户均匀分配到从线程上。而工作线程是竞争实现的，我们为工作线程设置了一个条件变量和对于消息队列的一把锁，当待处理消息队列为空时，cv.wait()。
抢到锁的线程会对用户消息进行解析，并将回复添加到用户档案的回复区。（看到档案的妙处了吗？原生线程并不支持返回值，我们只能通过传变量，更改变量的方式接收期望的返回值，用户档案充当了这个变量）。
工作线程写完回复，如何通知从线程进行send？我们使用了一个小技巧，将该客户的触发方式从只读改为读写，当客户的写缓冲区为空时，就会触发可写信号。阻塞在epoll_wait()的从线程就会被唤醒，将客户档案的回复发出去。当客户档案的回复区为空时，说明回复发完了，我们就可以将触发方式改回只读。（否则由于写缓冲区为空，则触发，会一直返回），
我们虽然是借助写触发，但实际是希望：当有回复又可写时才那么做。

线程安全：
由于从线程的消息队列是线程自己持有的，不存在线程竞争情况，无需加锁。
而工作线程的队列是公有的，我们只有一个线程池，公有的工作函数和待处理消息队列。线程竞争队列，从队列取数据，需要加锁访问。
写给客户的回复由工作线程写，由从线程取并发送，存在竞争。需要加锁实现互斥访问。
异常情况处理：如果客户断开连接，从线程会释放指针，而工作线程此时如果正在写该客户的回复，就会访问野指针导致崩溃，我们需要引入shared_ptr解决这个问题。
这实际上有点困难，因为客户的档案——在linux中为我们设计的是一个裸指针。当我们读取客户的消息，你可能想到我们可以为这个取出的裸指针创建一个shared_ptr对象。但是想象这种情况，从线程把客户消息提交给工作线程后，回到epoll_wait()进行等待，此时虽然该局部shared_ptr出了范围，引用计数-1，但由于工作线程仍然持有，所以还没有被释放。从线程再一次收到该客户的消息，又取出裸指针，又创建一个新的shared_ptr对象，此时它发现读到的字节数为0，客户表示要断开连接，从线程走完这一步，出了读触发逻辑，shared_ptr对象销毁，引用计数归零，该裸指针被释放。此时工作线程仍然在试图向那个指针写，这就爆炸了。
所以，由于工作线程和从线程收发（也就是用户状态）是解耦的，分离的，不可得知的状态，我们想要联系它们——我们想要工作线程正常工作，必须要有一个稳定的外部的shared_ptr来保证客户指针不被释放，这是重要的，更准确的说就是保证当我们使用客户档案指针的时候，最好利用的都是同一个控制块。
这正是共享指针的原则：多个指针指向同一个对象，共用同一个控制块，任何一方持有，则对象不被释放：补充注解如下：
Shared_ptr的原理是这样的，除了单纯的指针以外，我们存了一个控制块指针，控制块存了引用计数，所有的shared_ptr都持有这个控制块指针，如果还有人在用这个指针，那么就不会释放该指针。

详见shared_ptr使用指南：
<img width="415" height="72" alt="image" src="https://github.com/user-attachments/assets/55268b0d-bb3e-4ab6-9f8b-8ab18d814656" />



我们有两个办法实现这个：
1.自己存档一份客户套接字和连接信息指针的对应（也就是自己写一个map）。直接从map里取出那个shared_ptr,交给工作线程，这样就算客户在工作线程中途断开连接，我们从map中删掉这个指针信息，由于工作线程本身还持有这个shared_ptr，指针仍然不会被释放，所以不会出问题。
2.不存档map，但需要保存一个外部的shared_ptr，可供我们找回。
我们让HttpConnection类继承：
class HttpConnection : public enable_shared_from_this<HttpConnection>
然后存档一个shared_ptr作为基准，auto ptr = rawptr->shared_from_this();就能获得原先的控制块信息。









